
Beyond the five common patterns (Converging, Slow-Fast, Sliding Window, Diverging, and Multi-structure), there are several specialized "Two-Pointer" variations used in more niche or complex scenarios.
Here are the additional ways to implement and think about two-pointer logic:
1. The "Read-Write" Pointers (In-place Transformation)
This is the most common "hidden" two-pointer technique. Both pointers move in the same direction, but they serve different purposes: one scans the data (Read) and the other tracks the boundary of the modified data (Write).
Movement: Same direction, but the "Write" pointer only moves when a specific condition is met.
Common Applications:
Remove Duplicates from Sorted Array: The "Read" pointer iterates through everything; the "Write" pointer only moves when the current element is different from the last "written" element.
Move Zeroes: The "Read" pointer finds non-zero elements; the "Write" pointer tracks where the next non-zero should be placed.
String Compression: "Read" pointer counts occurrences; "Write" pointer overwrites the array with the character and the count.
2. The "Saddleback" Search (2D Two Pointers)
Used specifically for searching in a 2D Matrix that is sorted both row-wise and column-wise.
Movement: You start at the Top-Right (or Bottom-Left) corner.
If the target is smaller, move Left (decreasing the value).
If the target is larger, move Down (increasing the value).
Key Insight: This allows you to eliminate an entire row or an entire column in every single step, reducing 
O
(
N
×
M
)
O(N×M)
 search to 
O
(
N
+
M
)
O(N+M)
.
3. Binary Search as "Logarithmic" Two Pointers
While we often categorize Binary Search separately, it is technically a two-pointer implementation.
Movement: low and high pointers. Instead of moving by 1 unit, they jump to the mid.
Two-Pointer Application:
Search in Rotated Sorted Array: Using the relationship between arr[low], arr[mid], and arr[high] to decide which half is sorted.
Median of Two Sorted Arrays: Maintaining two pointers across two different arrays and moving them based on a binary search logic.
4. Interval Pointers (The "Sweep" Logic)
Used when dealing with intervals (start and end times). Instead of pointing at elements, you point at the boundaries of events.
Movement: One pointer iterates through "Start Times" and another through "End Times" (after sorting both).
Common Applications:
Meeting Rooms II: Move the "End Time" pointer only when a meeting finishes before the next one starts. If not, you need a new room.
Interval List Intersections: Use two pointers to compare the end-points of two interval lists to find overlaps.
5. Triple Pointers (Partitioning)
Sometimes two pointers aren't enough to track the necessary states. A third pointer is added to manage a "middle" or "unknown" section.
The Dutch National Flag Problem:
low: Boundary for 0s.
mid: The current element being scanned.
high: Boundary for 2s.
Movement: The mid pointer scans. If it sees a 0, it swaps with low; if it sees a 2, it swaps with high.
6. Cyclic Pointers (Index as a Pointer)
In problems involving permutations or missing numbers where the array contains values in the range 
[
0
,
n
]
[0,n]
, the values themselves act as pointers to the next index.
Movement: You don't use a variable like i++. Instead, you use i = nums[i].
Common Applications:
Find the Duplicate Number: If the array is treated as a linked list where index -> value, the duplicate number is the start of a cycle.
First Missing Positive: Using the values to "point" to their correct home index and swapping them into place.
7. The "Two-Pass" Greedy Pointers
Some problems require two separate two-pointer passes—one from left-to-right and one from right-to-left—to gather "prefix" and "suffix" information.
Common Applications:
Trapping Rain Water: Use one pointer from each end (converging) to track the leftMax and rightMax heights simultaneously to calculate water trapped at the current shorter side.
Candy Problem: One pass to satisfy the condition relative to the left neighbor, a second pass for the right neighbor.
Summary of Movement Logic:
Pattern	Pointer 1	Pointer 2	Primary Use Case
Read-Write	Scans all elements	Tracks destination	In-place array cleanup
Saddleback	Row index	Column index	2D Sorted Matrix search
Interval	List A index	List B index	Meeting/Overlap logic
Cyclic	Current Index	nums[index]	Array permutations / Cycle detection
Partition	low boundary	high boundary	Sorting categories (3-way)